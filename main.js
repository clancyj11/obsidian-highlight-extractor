/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HighlightExtractorPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  templatePath: "",
  extractedNotesFolder: "Extracted Highlights",
  includeParagraphContext: false
};
var HighlightExtractorPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("highlighter", "Extract highlights", async () => {
      await this.extractHighlights();
    });
    this.addCommand({
      id: "extract-highlights",
      name: "Extract highlights from current note",
      callback: async () => {
        await this.extractHighlights();
      }
    });
    this.addSettingTab(new HighlightExtractorSettingTab(this.app, this));
  }
  async extractHighlights() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian.Notice("No active file");
      return;
    }
    const content = await this.app.vault.read(activeFile);
    const highlights = this.parseHighlights(content, activeFile);
    if (highlights.length === 0) {
      new import_obsidian.Notice("No highlights found in the current note");
      return;
    }
    const updatedContent = await this.addBlockReferences(content, highlights);
    await this.app.vault.modify(activeFile, updatedContent);
    let template = await this.getTemplate();
    const newNoteContent = await this.createExtractedNote(highlights, activeFile, template);
    const baseFileName = `${activeFile.basename} - Highlights`;
    const folder = this.settings.extractedNotesFolder;
    if (folder && !await this.app.vault.adapter.exists(folder)) {
      await this.app.vault.createFolder(folder);
    }
    const newFilePath = folder ? `${folder}/${baseFileName}.md` : `${baseFileName}.md`;
    const newFile = await this.app.vault.create(newFilePath, newNoteContent);
    await this.app.workspace.getLeaf().openFile(newFile);
    new import_obsidian.Notice(`Extracted ${highlights.length} highlights to ${newFile.name}`);
  }
  parseHighlights(content, file) {
    const highlights = [];
    const lines = content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const regex = /==(.*?)==/g;
      let match;
      while ((match = regex.exec(line)) !== null) {
        const blockId = this.generateBlockId(match[1]);
        const highlight = {
          text: match[1],
          lineNumber: i + 1,
          blockId,
          context: this.settings.includeParagraphContext ? this.getParagraphContext(lines, i) : void 0
        };
        highlights.push(highlight);
      }
    }
    return highlights;
  }
  generateBlockId(text) {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, "0");
    const day = String(now.getDate()).padStart(2, "0");
    const hours = String(now.getHours()).padStart(2, "0");
    const minutes = String(now.getMinutes()).padStart(2, "0");
    const seconds = String(now.getSeconds()).padStart(2, "0");
    if (!this.highlightCounter || this.lastExtractionTime !== `${year}${month}${day}${hours}${minutes}${seconds}`) {
      this.highlightCounter = 1;
      this.lastExtractionTime = `${year}${month}${day}${hours}${minutes}${seconds}`;
    } else {
      this.highlightCounter++;
    }
    const counter = String(this.highlightCounter).padStart(2, "0");
    return `${year}${month}${day}${hours}${minutes}${seconds}${counter}`;
  }
  async addBlockReferences(content, highlights) {
    const lines = content.split("\n");
    for (let i = highlights.length - 1; i >= 0; i--) {
      const highlight = highlights[i];
      const lineIndex = highlight.lineNumber - 1;
      if (highlight.blockId && lines[lineIndex]) {
        if (!lines[lineIndex].match(/ \^[a-z0-9-]+$/)) {
          lines[lineIndex] = lines[lineIndex] + ` ^${highlight.blockId}`;
        }
      }
    }
    return lines.join("\n");
  }
  getParagraphContext(lines, lineIndex) {
    let start = lineIndex;
    let end = lineIndex;
    while (start > 0 && lines[start - 1].trim() !== "") {
      start--;
    }
    while (end < lines.length - 1 && lines[end + 1].trim() !== "") {
      end++;
    }
    const paragraph = lines.slice(start, end + 1).join("\n");
    return paragraph;
  }
  async getTemplate() {
    if (!this.settings.templatePath) {
      return this.getDefaultTemplate();
    }
    const templateFile = this.app.vault.getAbstractFileByPath(this.settings.templatePath);
    if (templateFile instanceof import_obsidian.TFile) {
      return await this.app.vault.read(templateFile);
    }
    new import_obsidian.Notice("Template file not found, using default template");
    return this.getDefaultTemplate();
  }
  getDefaultTemplate() {
    return `# {{title}} - Extracted Highlights

**Source:** [[{{source}}]]
**Date Extracted:** {{date}}
**Total Highlights:** {{count}}

---

{{highlights}}`;
  }
  async createExtractedNote(highlights, sourceFile, template) {
    const date = new Date().toLocaleDateString();
    const formattedHighlights = highlights.map((h, index) => {
      let highlightBlock = `## Highlight ${index + 1}

`;
      highlightBlock += `> ${h.text}

`;
      if (h.blockId) {
        highlightBlock += `**Location:** [[${sourceFile.basename}#^${h.blockId}]]
`;
      } else {
        highlightBlock += `**Location:** [[${sourceFile.basename}]] (Line ${h.lineNumber})
`;
      }
      if (h.context && this.settings.includeParagraphContext) {
        highlightBlock += `
**Context:**
${h.context}
`;
      }
      return highlightBlock;
    }).join("\n---\n\n");
    let noteContent = template;
    noteContent = noteContent.replace("{{title}}", sourceFile.basename);
    noteContent = noteContent.replace("{{source}}", sourceFile.basename);
    noteContent = noteContent.replace("{{date}}", date);
    noteContent = noteContent.replace("{{count}}", highlights.length.toString());
    noteContent = noteContent.replace("{{highlights}}", formattedHighlights);
    return noteContent;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var HighlightExtractorSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Highlight Extractor Settings" });
    new import_obsidian.Setting(containerEl).setName("Template file path").setDesc("Path to the template file for extracted highlights (leave empty for default)").addText((text) => text.setPlaceholder("Templates/Highlight Template.md").setValue(this.plugin.settings.templatePath).onChange(async (value) => {
      this.plugin.settings.templatePath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Extracted notes folder").setDesc("Folder where extracted highlight notes will be saved").addText((text) => text.setPlaceholder("Extracted Highlights").setValue(this.plugin.settings.extractedNotesFolder).onChange(async (value) => {
      this.plugin.settings.extractedNotesFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Include paragraph context").setDesc("Include the full paragraph containing each highlight").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeParagraphContext).onChange(async (value) => {
      this.plugin.settings.includeParagraphContext = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Template Variables" });
    containerEl.createEl("p", { text: "Available variables for your template:" });
    const variableList = containerEl.createEl("ul");
    variableList.createEl("li", { text: "{{title}} - Source note title" });
    variableList.createEl("li", { text: "{{source}} - Source note name (for linking)" });
    variableList.createEl("li", { text: "{{date}} - Current date" });
    variableList.createEl("li", { text: "{{count}} - Number of highlights" });
    variableList.createEl("li", { text: "{{highlights}} - The formatted highlights" });
  }
};
